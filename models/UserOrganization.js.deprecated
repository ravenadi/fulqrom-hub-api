const mongoose = require('mongoose');
const tenantPlugin = require('../plugins/tenantPlugin');

/**
 * UserOrganization Junction Schema
 *
 * Manages the many-to-many relationship between Users and Organizations.
 * A user can belong to multiple organizations, and an organization can have multiple users.
 * One organization is marked as "primary" for each user - this determines which
 * organization's data the user sees by default.
 */
const UserOrganizationSchema = new mongoose.Schema({
  // User reference
  user_id: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true,
    index: true
  },

  // Organization reference
  organization_id: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Organization',
    required: true,
    index: true
  },

  // Primary organization flag
  // Only ONE organization can be primary per user
  is_primary: {
    type: Boolean,
    default: false,
    index: true
  },

  // User's role within this organization
  // This allows the same user to have different roles in different organizations
  role_id: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Role',
    required: false // Can be set later after user accepts invitation
  },

  // Membership status
  status: {
    type: String,
    required: true,
    enum: ['invited', 'active', 'suspended', 'removed'],
    default: 'invited',
    index: true
  },

  // Invitation details
  invited_by: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: false
  },
  invited_at: {
    type: Date,
    default: Date.now
  },
  invitation_token: {
    type: String,
    unique: true,
    sparse: true // Only unique if not null
  },
  invitation_expires_at: {
    type: Date,
    default: function() {
      // Invitation expires in 7 days
      const expiryDate = new Date();
      expiryDate.setDate(expiryDate.getDate() + 7);
      return expiryDate;
    }
  },

  // Acceptance details
  accepted_at: {
    type: Date,
    default: null
  },

  // Audit fields
  created_at: {
    type: Date,
    default: Date.now,
    index: true
  },
  updated_at: {
    type: Date,
    default: Date.now
  },
  deleted_at: {
    type: Date,
    default: null
  }
}, {
  timestamps: false, // We manage timestamps manually
  collection: 'user_organisations'
});

// Compound Indexes
// Ensure a user can only belong to an organization once
UserOrganizationSchema.index({ user_id: 1, organization_id: 1 }, { unique: true });

// Efficiently find all organizations for a user
UserOrganizationSchema.index({ user_id: 1, status: 1 });

// Efficiently find all users in an organization
UserOrganizationSchema.index({ organization_id: 1, status: 1 });

// Find user's primary organization
UserOrganizationSchema.index({ user_id: 1, is_primary: 1, status: 1 });

// Lookup by invitation token
UserOrganizationSchema.index({ invitation_token: 1 }, { sparse: true });

// Find expiring invitations
UserOrganizationSchema.index({ status: 1, invitation_expires_at: 1 });

// Pre-save middleware to update timestamps
UserOrganizationSchema.pre('save', function(next) {
  if (this.isModified() && !this.isNew) {
    this.updated_at = new Date();
  }
  next();
});

// Pre-save middleware to ensure only one primary organization per user
UserOrganizationSchema.pre('save', async function(next) {
  // If this is being set as primary, unset all other primary flags for this user
  if (this.isModified('is_primary') && this.is_primary === true) {
    await this.constructor.updateMany(
      {
        user_id: this.user_id,
        _id: { $ne: this._id },
        is_primary: true
      },
      {
        $set: { is_primary: false, updated_at: new Date() }
      }
    );
  }
  next();
});

// Virtual: Check if invitation is expired
UserOrganizationSchema.virtual('is_invitation_expired').get(function() {
  if (this.status !== 'invited') return false;
  return new Date() > this.invitation_expires_at;
});

// Virtual: Days until invitation expires
UserOrganizationSchema.virtual('invitation_days_remaining').get(function() {
  if (this.status !== 'invited') return 0;
  const now = new Date();
  const diff = this.invitation_expires_at - now;
  return Math.max(0, Math.ceil(diff / (1000 * 60 * 60 * 24)));
});

// Ensure virtual fields are serialized
UserOrganizationSchema.set('toJSON', { virtuals: true });
UserOrganizationSchema.set('toObject', { virtuals: true });

// Instance method: Accept invitation
UserOrganizationSchema.methods.acceptInvitation = async function() {
  if (this.status !== 'invited') {
    throw new Error('Only invited memberships can be accepted');
  }
  if (this.is_invitation_expired) {
    throw new Error('Invitation has expired');
  }

  this.status = 'active';
  this.accepted_at = new Date();
  this.invitation_token = null; // Clear the token after acceptance

  // If user has no primary organization, make this one primary
  const hasPrimary = await this.constructor.findOne({
    user_id: this.user_id,
    is_primary: true,
    status: 'active'
  });

  if (!hasPrimary) {
    this.is_primary = true;
  }

  return this.save();
};

// Instance method: Suspend membership
UserOrganizationSchema.methods.suspend = async function() {
  this.status = 'suspended';
  return this.save();
};

// Instance method: Reactivate membership
UserOrganizationSchema.methods.reactivate = async function() {
  this.status = 'active';
  return this.save();
};

// Instance method: Remove membership (soft delete)
UserOrganizationSchema.methods.removeMembership = async function() {
  this.status = 'removed';
  this.deleted_at = new Date();
  this.is_primary = false;

  // If this was the primary organization, set another active org as primary
  const anotherActiveOrg = await this.constructor.findOne({
    user_id: this.user_id,
    status: 'active',
    _id: { $ne: this._id }
  });

  if (anotherActiveOrg) {
    anotherActiveOrg.is_primary = true;
    await anotherActiveOrg.save();
  }

  return this.save();
};

// Static method: Find user's primary organization
UserOrganizationSchema.statics.findPrimaryOrganization = function(userId) {
  return this.findOne({
    user_id: userId,
    is_primary: true,
    status: 'active'
  }).populate('organization_id');
};

// Static method: Find all organizations for a user
UserOrganizationSchema.statics.findUserOrganizations = function(userId, activeOnly = true) {
  const query = { user_id: userId };
  if (activeOnly) {
    query.status = 'active';
  }
  return this.find(query).populate('organization_id').sort({ is_primary: -1, created_at: -1 });
};

// Static method: Find all users in an organization
UserOrganizationSchema.statics.findOrganizationUsers = function(organizationId, activeOnly = true) {
  const query = { organization_id: organizationId };
  if (activeOnly) {
    query.status = 'active';
  }
  return this.find(query).populate('user_id').sort({ created_at: -1 });
};

// Static method: Set primary organization for user
UserOrganizationSchema.statics.setPrimaryOrganization = async function(userId, organizationId) {
  // First, verify the user belongs to this organization
  const membership = await this.findOne({
    user_id: userId,
    organization_id: organizationId,
    status: 'active'
  });

  if (!membership) {
    throw new Error('User is not an active member of this organization');
  }

  // Unset all other primary flags for this user
  await this.updateMany(
    {
      user_id: userId,
      is_primary: true
    },
    {
      $set: { is_primary: false, updated_at: new Date() }
    }
  );

  // Set this organization as primary
  membership.is_primary = true;
  return membership.save();
};

// Static method: Find pending invitations for a user
UserOrganizationSchema.statics.findPendingInvitations = function(userId) {
  return this.find({
    user_id: userId,
    status: 'invited',
    invitation_expires_at: { $gt: new Date() }
  }).populate('organization_id invited_by');
};

// Static method: Find expiring invitations (for cleanup jobs)
UserOrganizationSchema.statics.findExpiredInvitations = function() {
  return this.find({
    status: 'invited',
    invitation_expires_at: { $lt: new Date() }
  });
};

// Static method: Get organization member count
UserOrganizationSchema.statics.getOrganizationMemberCount = async function(organizationId) {
  return this.countDocuments({
    organization_id: organizationId,
    status: { $in: ['active', 'invited'] }
  });
};

// Static method: Check if user can be added to organization (quota check)
UserOrganizationSchema.statics.canAddUserToOrganization = async function(organizationId) {
  const Organization = mongoose.model('Organization');
  const org = await Organization.findById(organizationId);

  if (!org) {
    throw new Error('Organization not found');
  }

  const currentCount = await this.getOrganizationMemberCount(organizationId);
  return currentCount < org.limits.users;
};

// Apply tenant isolation plugin
UserOrganizationSchema.plugin(tenantPlugin);

module.exports = mongoose.model('UserOrganization', UserOrganizationSchema);
